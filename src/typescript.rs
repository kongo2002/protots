use crate::errors::PtError;
use crate::parser::{Elem, Enum, EnumValue, Field, Flag, Msg, Proto};

const DEFAULT_CAPACITY: usize = 10 * 1024;

pub fn to_schema(proto: &Proto) -> Result<String, PtError> {
    let mut str = String::with_capacity(DEFAULT_CAPACITY);

    str.push_str("//\n");
    str.push_str("// Code generated by protots - DO NOT EDIT\n");
    str.push_str(format!("// Source: {}\n", proto.file).as_str());
    str.push_str("//\n");
    str.push_str("\n");
    str.push_str("import { z } from \"zod\";");
    str.push_str("\n");
    str.push_str("\n");

    for elem in &proto.elems {
        match elem {
            Elem::Message(msg) => str.push_str(format_msg(msg, "").as_str()),
            Elem::Enum(e) => str.push_str(format_enum(e, "").as_str()),
            _ => (),
        }
    }

    Ok(str)
}

fn format_msg(msg: &Msg, parent: &str) -> String {
    let mut sub_messages = Vec::new();
    let mut str = String::with_capacity(512);
    let message_name = message_type_name(&msg.name, parent);
    let schema_name = format!("{}Schema", message_name);

    str.push_str(format!("export const {} = z.object({{\n", schema_name).as_str());

    for field in &msg.fields {
        if let Some(value) = format_field(field, &message_name, &mut sub_messages) {
            str.push_str("  ");
            str.push_str(value.as_str());
            str.push_str(",\n");
        }
    }

    str.push_str("});\n\n");

    str.push_str(
        format!(
            "export type {} = z.infer<typeof {}>;\n\n",
            message_name, schema_name
        )
        .as_str(),
    );

    for sub_msg in sub_messages {
        str.push_str(&sub_msg);
    }

    str
}

fn format_field(field: &Field, parent: &str, elements: &mut Vec<String>) -> Option<String> {
    match field {
        Field::Single {
            name,
            field_type,
            idx: _,
            flag,
        } => {
            if let Some(tname) = type_name(&field_type) {
                Some(format!(
                    "{}: {}",
                    snake_to_camel(name),
                    flagged_field(tname, flag)
                ))
            } else {
                None
            }
        }
        Field::Map {
            name,
            key_type,
            value_type,
            idx: _,
        } => match (type_name(key_type), type_name(value_type)) {
            (Some(kt), Some(vt)) => Some(format!(
                "{}: z.record({}, {})",
                snake_to_camel(name),
                kt,
                vt
            )),
            _ => None,
        },
        Field::OneOf { name, fields } => Some(format!(
            "{}: {}",
            snake_to_camel(name),
            format_oneof(fields, parent, elements)
        )),
        Field::SubMessage(msg) => {
            elements.push(format_msg(msg, parent));
            None
        }
        Field::SubEnum(e) => {
            elements.push(format_enum(e, parent));
            None
        }
        _ => None,
    }
}

fn format_oneof(oneof: &Vec<Field>, parent: &str, elements: &mut Vec<String>) -> String {
    let cases = oneof
        .iter()
        .flat_map(|case| format_field(case, parent, elements))
        .collect::<Vec<_>>();

    // z.union does not support single element lists
    if cases.len() == 1 {
        let single_field = &cases[0];
        return format!("z.object({{ {} }})", single_field);
    }

    format!("z.union([{}])", cases.join(", "))
}

fn format_enum(value: &Enum, parent: &str) -> String {
    let mut str = String::with_capacity(512);
    let enum_name = message_type_name(&value.name, parent);
    let schema_name = format!("{}Schema", enum_name);

    str.push_str(format!("export enum {} = {{\n", enum_name).as_str());

    for value in &value.values {
        match value {
            EnumValue::Single { name, idx: _ } => {
                str.push_str(format!("  {} = \"{}\",\n", name, name).as_str())
            }
            EnumValue::Reserved { idx: _ } => (),
        }
    }

    str.push_str("}\n\n");

    let default_case = value.values.iter().find_map(|value| match value {
        EnumValue::Single { name, idx } => {
            if *idx == 0 {
                Some(name)
            } else {
                None
            }
        }
        EnumValue::Reserved { idx: _ } => None,
    });

    let catch = default_case
        .map(|def_case| format!(".catch({}.{})", enum_name, def_case))
        .unwrap_or_else(|| String::new());

    str.push_str(
        format!(
            "export const {} = z.nativeEnum({}){};\n\n",
            schema_name, enum_name, catch
        )
        .as_str(),
    );

    str
}

fn type_name(type_name: &str) -> Option<&str> {
    match type_name {
        // native types

        // strings
        "string" | "bytes" => Some("z.string()"),
        // numbers
        "int32" | "double" | "float" | "uint32" | "sint32" | "fixed32" | "sfixed32" => {
            Some("z.number()")
        }
        // bigint numbers
        "int64" | "uint64" | "fixed64" | "sfixed64" | "sint64" => Some("z.coerce.bigint()"),
        // boolean
        "bool" => Some("z.boolean()"),

        // external types
        "google.protobuf.Timestamp" => Some("z.coerce.date()"),
        _ => None,
    }
}

fn flagged_field(field: &str, flag: &Flag) -> String {
    match flag {
        Flag::Optional => format!("z.optional({})", field),
        Flag::Repeated => format!("z.array({})", field),
        Flag::None => field.to_string(),
        Flag::Required => field.to_string(),
    }
}

fn message_type_name(name: &str, parent: &str) -> String {
    if parent.is_empty() {
        name.to_string()
    } else {
        format!("{}_{}", parent, name)
    }
}

fn to_camel(word: &str) -> String {
    let first_char = word.chars().nth(0);
    first_char
        .map(|first| {
            let mut new_word = Vec::with_capacity(word.len());
            new_word.push(first.to_ascii_uppercase());
            new_word.extend(word.chars().skip(1));
            new_word.into_iter().collect()
        })
        .unwrap_or_else(|| word.to_string())
}

fn snake_to_camel(input: &str) -> String {
    input
        .split('_')
        .filter(|part| !part.is_empty())
        .enumerate()
        .map(|(idx, part)| {
            if idx > 0 {
                to_camel(part)
            } else {
                part.to_owned()
            }
        })
        .collect::<Vec<_>>()
        .concat()
}
